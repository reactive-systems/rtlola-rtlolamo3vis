use core::slice;
use std::{
    ffi::{c_char, CStr, CString},
    mem,
    ops::Deref,
    ptr::{self, null, null_mut},
};

use error::FfiError;
use ffi::RTLolaMonitor;
use log::debug;
use rtlola_interpreter::time::AbsoluteFloat;
use verdict_sink::Limit;

use crate::verdict_sink::GraphPoint;

/// cbindgen::ignore
pub mod error;
/// cbindgen::ignore
pub mod event_source;
/// cbindgen::ignore
pub mod ffi;
/// cbindgen::ignore
pub mod verdict_sink;

pub(crate) type InputTime = AbsoluteFloat;
pub(crate) type OutputTime = AbsoluteFloat;

#[repr(C)]
pub struct Duration {
    pub time_in_secs: f64,
}

#[no_mangle]
/// # Safety
/// Can only be called on pointer generated by the [new_monitor] function
pub unsafe extern "C" fn free_monitor(monitor_ptr: *mut RTLolaMonitor) {
    debug!("Dropping monitor at: {:?}", monitor_ptr);
    match monitor_ptr.as_mut() {
        None => eprint!("Got null pointer"),
        Some(monitor_ptr) => {
            let _ = Box::from_raw(monitor_ptr);
        }
    };
}

#[no_mangle]
pub extern "C" fn new_monitor(
    event_source_cfg: *const c_char,
    spec_cfg: *const c_char,
    verdict_sink_cfg: GraphDescriptions,
) -> MonitorResult {
    dbg!(RTLolaMonitor::from_raw(event_source_cfg, spec_cfg, verdict_sink_cfg).into())
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct GraphDescriptions {
    pub(crate) num_lines: u8,
    pub(crate) lines: *const GraphLineDescription,
    pub(crate) num_limits: u8,
    pub(crate) limits: *const LimitDescription,
}

impl TryFrom<GraphDescriptions> for Vec<GraphPoint<String>> {
    type Error = FfiError;

    fn try_from(value: GraphDescriptions) -> Result<Self, Self::Error> {
        let GraphDescriptions {
            num_lines,
            lines,
            num_limits,
            limits,
        } = value;
        unsafe { slice::from_raw_parts(lines, num_lines.into()) }
            .iter()
            .map(|point| point.try_into())
            .collect::<Result<Vec<_>, _>>()
    }
}

impl TryFrom<GraphDescriptions> for Vec<Limit<String>> {
    type Error = FfiError;

    fn try_from(value: GraphDescriptions) -> Result<Self, Self::Error> {
        let GraphDescriptions {
            num_lines,
            lines,
            num_limits,
            limits,
        } = value;
        unsafe { slice::from_raw_parts(limits, num_limits.into()) }
            .iter()
            .map(|point| point.try_into())
            .collect::<Result<Vec<_>, _>>()
    }
}

#[repr(C)]
#[derive(Debug)]
pub struct GraphLineDescription {
    pub(crate) graph_id: u8,
    pub(crate) line_id: u8,
    pub(crate) point: *const u8,
    pub(crate) point_length: u8,
}

#[repr(C)]
#[derive(Debug)]
pub struct LimitDescription {
    pub(crate) graph_id: u8,
    pub(crate) axis: u8,
    pub(crate) stream: *const u8,
    pub(crate) stream_length: u8,
}

impl TryFrom<&GraphLineDescription> for GraphPoint<String> {
    type Error = FfiError;

    fn try_from(value: &GraphLineDescription) -> Result<Self, Self::Error> {
        let GraphLineDescription {
            graph_id,
            line_id,
            point,
            point_length,
        } = value;
        //let point = unsafe { CStr::from_ptr(*point) };
        //println!("point {:?}", point);
        // let point = std::str::from_utf8(*point).unwrap();
        let point = unsafe { std::slice::from_raw_parts(*point, *point_length as usize) };
        let point = std::str::from_utf8(&point).unwrap();
        println!("point from utf8 {:?}", point);
        //let point = point.to_str().map_err(FfiError::Utf8Error)?;
        Ok(Self {
            graph_id: *graph_id,
            line_id: *line_id,
            point: point.to_string(),
        })
    }
}

impl TryFrom<&LimitDescription> for Limit<String> {
    type Error = FfiError;

    fn try_from(value: &LimitDescription) -> Result<Self, Self::Error> {
        let LimitDescription {
            graph_id,
            axis,
            stream,
            stream_length,
        } = value;
        //let point = unsafe { CStr::from_ptr(*point) };
        //println!("point {:?}", point);
        // let point = std::str::from_utf8(*point).unwrap();
        let stream = unsafe { std::slice::from_raw_parts(*stream, *stream_length as usize) };
        let point = std::str::from_utf8(&stream).unwrap();
        println!("point from utf8 {:?}", stream);
        //let point = point.to_str().map_err(FfiError::Utf8Error)?;
        let is_x = (*axis as char) == 'x' || (*axis as char) == 'X';
        Ok(Self {
            graph_id: *graph_id,
            is_x,
            stream: point.to_string(),
        })
    }
}

#[repr(C)]
#[allow(non_camel_case_types)]
pub struct GraphPoints {
    pub graph_id: u8,
    pub line_id: u8,
    pub x_coord: f64,
    pub y_coord: f64,
    pub triggered: bool,
}

#[repr(C)]
#[allow(non_camel_case_types)]
pub struct Trigger {
    pub timestamp: u64,
    pub length_msg: i32,
    pub msg: *const u8,
}

#[repr(C)]
#[allow(non_camel_case_types)]
pub struct Log {
    pub length_msg: u8,
    pub msg: *const u8,
}

#[repr(C)]
#[allow(non_camel_case_types)]
pub struct Verdicts {
    pub num_parsed_bytes: u64,
    pub num_points: u8,
    pub points: *mut GraphPoints,
    pub num_trigger: u8,
    pub triggers: *mut Trigger,
    pub num_logs: u8,
    pub logs: *mut Log,
    pub num_limits: u8,
    pub limits: *mut Limits,
}

#[repr(C)]
#[allow(non_camel_case_types)]
pub struct Limits {
    pub graph_id: u8,
    pub min: f64,
    pub max: f64,
    pub is_x: bool,
}

#[repr(C)]
#[allow(non_camel_case_types)]
pub struct MonitorResult {
    pub error: u8,
    pub pointer: *mut RTLolaMonitor,
    pub error_length: i32,
    pub error_message: *const u8,
}

impl std::fmt::Debug for MonitorResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("MonitorResult")
            .field("error", &self.error)
            .field("pointer", &self.pointer)
            .field("error_length", &self.error_length)
            .field("error_message", &self.error_message)
            .finish()
    }
}

impl From<Result<RTLolaMonitor, FfiError>> for MonitorResult {
    fn from(value: Result<RTLolaMonitor, FfiError>) -> Self {
        match value {
            Ok(mon) => MonitorResult {
                error: 0,
                pointer: Box::into_raw(Box::new(mon)),
                error_length: 0,
                error_message: null(),
            },
            Err(err) => {
                let length: i32 = err.to_string().len().try_into().unwrap();
                let msg = err.to_string().as_bytes().to_owned();
                let msg = mem::ManuallyDrop::new(msg);
                MonitorResult {
                    error: 1,
                    pointer: ptr::null::<RTLolaMonitor>() as *mut RTLolaMonitor,
                    error_length: length,
                    error_message: msg.as_ptr(),
                }
            }
        }
    }
}

#[no_mangle]
/// # Safety
/// Can be only called on pointers returned by [accept_event]
pub unsafe extern "C" fn free_verdicts(verdicts_ptr: *mut Verdicts) {
    debug!("Dropping verdicts at: {:?}", verdicts_ptr);
    let verdicts: Box<Verdicts> = unsafe {
        if verdicts_ptr.is_null() {
            return;
        }
        Box::from_raw(verdicts_ptr)
    };
    let Verdicts {
        num_parsed_bytes: _,
        num_points,
        points,
        num_trigger,
        triggers,
        num_logs,
        logs,
        num_limits,
        limits,
    } = *verdicts;
    let _ = unsafe { Vec::from_raw_parts(triggers, num_trigger as usize, num_trigger as usize) };
    let _ = unsafe { Vec::from_raw_parts(points, num_points as usize, num_points as usize) };
    let _ = unsafe { Vec::from_raw_parts(logs, num_logs as usize, num_logs as usize) };
}

#[no_mangle]
pub unsafe extern "C" fn accept_event(
    mon: *mut RTLolaMonitor,
    bytes: *mut u8,
    len: usize,
    ts: Duration,
) -> *mut Verdicts {
    let monitor = unsafe {
        match mon.as_mut() {
            Some(p) => p,
            None => {
                let msg = "Null pointer to monitor".to_string();
                let length: u8 = msg.len().try_into().unwrap();
                let msg = msg.to_string().as_bytes().to_owned();
                let msg = mem::ManuallyDrop::new(msg);
                let log = Log {
                    length_msg: length,
                    msg: msg.as_ptr(),
                };
                let mut logs = vec![log];
                logs.shrink_to_fit();
                let mut logs = mem::ManuallyDrop::new(logs);
                return Box::into_raw(Box::new(Verdicts {
                    num_parsed_bytes: 0,
                    num_points: 0,
                    points: null_mut(),
                    num_trigger: 0,
                    triggers: null_mut(),
                    num_logs: 1,
                    logs: logs.as_mut_ptr(),
                    num_limits: 0,
                    limits: null_mut(),
                }));
            }
        }
    };
    let bytes = unsafe { slice::from_raw_parts_mut(bytes, len) };
    let ts = std::time::Duration::from_secs_f64(ts.time_in_secs);

    let (num_parsed_bytes, points, triggers, limits) = match monitor.accept_event(bytes, ts) {
        Ok(evs) => evs,
        Err(e) => {
            let msg = e.to_string();
            let length: u8 = msg.len().try_into().unwrap();
            println!("length message: {length}");
            let msg = msg.to_string().as_bytes().to_owned();
            let msg = mem::ManuallyDrop::new(msg);
            let log_e = Log {
                length_msg: length,
                msg: msg.as_ptr(),
            };
            let msg = "Could not build verdicts.".to_string();
            let length: u8 = msg.len().try_into().unwrap();
            println!("length message: {length}");
            let msg: Vec<u8> = msg.to_string().as_bytes().to_owned();
            let msg = mem::ManuallyDrop::new(msg);
            let log = Log {
                length_msg: length,
                msg: msg.as_ptr(),
            };
            let mut logs = vec![log_e, log];
            logs.shrink_to_fit();
            let mut logs = mem::ManuallyDrop::new(logs);
            return Box::into_raw(Box::new(Verdicts {
                num_parsed_bytes: 0,
                num_points: 0,
                points: null_mut(),
                num_trigger: 0,
                triggers: null_mut(),
                num_logs: 2,
                logs: logs.as_mut_ptr(),
                num_limits: 0,
                limits: null_mut(),
            }));
        }
    };

    let mut triggers = triggers
        .into_iter()
        .map(|(ts, msg)| {
            let length: i32 = msg.len().try_into().unwrap();
            let msg = msg.to_string().as_bytes().to_owned();
            let msg = mem::ManuallyDrop::new(msg);
            Trigger {
                timestamp: ts.as_secs(),
                msg: msg.as_ptr(),
                length_msg: length,
            }
        })
        .collect::<Vec<_>>();
    let num_triggers = triggers.len() as u8;
    triggers.shrink_to_fit();
    let mut triggers = mem::ManuallyDrop::new(triggers);

    let mut points = points
        .into_iter()
        .map(|point| {
            let point =
                GraphPoint::<(f64, f64, bool)>::new(point).expect("Convertion to Tuple failed");
            let verdict_sink::GraphPoint {
                graph_id,
                line_id,
                point: (x_coord, y_coord, triggered),
            } = point;
            GraphPoints {
                graph_id,
                line_id,
                x_coord,
                y_coord,
                triggered,
            }
        })
        .collect::<Vec<_>>();
    let num_points = points.len() as u8;
    points.shrink_to_fit();
    let mut points = mem::ManuallyDrop::new(points);

    let mut limits: Vec<Limits> = limits
        .into_iter()
        .map(|point| {
            let point = Limit::<(f64, f64)>::new(point).expect("Convertion to Tuple failed");
            let verdict_sink::Limit {
                graph_id,
                is_x,
                stream: (min, max),
            } = point;
            Limits {
                graph_id,
                min,
                max,
                is_x,
            }
        })
        .collect::<Vec<_>>();
    let num_limits = limits.len() as u8;
    limits.shrink_to_fit();
    let mut limits = mem::ManuallyDrop::new(limits);

    Box::into_raw(Box::new(Verdicts {
        num_parsed_bytes: num_parsed_bytes as u64,
        num_points: num_points,
        points: points.as_mut_ptr(),
        num_trigger: num_triggers,
        triggers: triggers.as_mut_ptr(),
        num_logs: 0,
        logs: null_mut(),
        num_limits: num_limits,
        limits: limits.as_mut_ptr(),
    }))
}
